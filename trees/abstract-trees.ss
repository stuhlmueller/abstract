
;; to do
;; -determine cases where exemplar and compressed models would be differentiated (i.e. where exemplar fails)
;; -look at using abstract without the recursion pattern
;; -look at recursive concepts where the flip parameter is drawn uniformly at random
;; -do program->sexpr inside beam-compression

;; -separate data generation between training and "test"
;; -infer recursion parameters

;; -compare the data generated from the uncompressed and compressed versions of the program to new data generated by the original concept

(import (_srfi :1)
        (church readable-scheme)
        (church external py-pickle)
        (srfi :13)
        (abstract))

(define draw-trees
  (py-pickle-script "./treedraw.py"))

;;prototype

(define a 'a)
(define b 'b)
(define c 'c)
(define d 'd)
(define e 'e)


(define growth-noise .05)
(define label-noise .05)
;;(define sample-size 5)
(define training-size 6)
(define generalize-size 40)
(define labels '(a b c d e))

(define (node x . subtrees)
  (if (flip (- 1 growth-noise))
      (delete '() (pair (noisy-label x) subtrees))
      '()))

(define (noisy-label x)
  (if (flip (- 1 label-noise))
      x
      (uniform-draw labels)))
  
(node 'a (node 'b) (node 'c (node 'd)))

;;model definitions
(define (prototype) (node 'a (node 'b (node 'c (node 'd) (node 'd)))))

(define (parameterized-parts)
  (define (part x)
    (node 'a x (node 'a x (node 'a x (node 'a x x) x) x) x))
  (part (if (flip .5)
            (node 'b)
            (node 'c))))

(define (single-recursion)
  (define (part)
    (node 'a
          (if (flip .8)
              (node 'b (part) (node c))
              (node 'd))))
  (node b (node b (node c) (node c)) (part)))

   
(define (multiple-recursion)
  (define (part)
    (node 'a
          (if (flip .5)
              (part)
              (node 'a))
          (if (flip .5)
              (part)
              (node 'b))))
  (node 'c (node 'b (node 'd (part))) (part)))

;;generate data from a model
(define (gen-data model amount)
  (delete '() (repeat amount model)))

;;returns unquoted labels...they were a problem somewhere...compressed programs?
(define (nodify-noquote tree)
  (if (null? tree)
      '()
      (append (list 'node (first tree))
              (map nodify-noquote (rest tree)))))


(define (nodify tree)
  (if (null? tree)
      '()
      (append (list 'node (list 'quote (first tree)))
              (map nodify (rest tree)))))

;;uniform-draw over nodified trees
(define (program-exemplar data)
  (let* ([all-examples (map nodify data)])
    (lambda () (eval (uniform-draw all-examples) (interaction-environment)))))

;;uniform-draw over trees (un-nodified)
(define (exemplar data)
  (lambda () (uniform-draw data)))

;;uniform-draw over compressed nodified trees
(define (program-compression data)
  (let* ([all-examples (map nodify-noquote data)]
         [prog (program->sexpr (beam-compression (list 'uniform-draw (pair 'list all-examples)) 1))])
    (pretty-print (list "compressed-program:" prog "size: " (size prog)))
    (lambda () (eval prog (interaction-environment)))))

;;takes a model and creates data for all the "derived models" exmemplar compressed program etc.
(define (process-model model name)
  (let* ([training-data (gen-data model training-size)]
         [training-fname (string-join (list name "-training.png") "")]
         [generalize-data (gen-data model generalize-size)]
         [generalization-fname (string-join (list name "-data.png") "")])
    (define (process-derived-model dmodel dname)
      (let* ([trained-model (dmodel training-data)]
             [dmodel-data (gen-data trained-model generalize-size)]
             [dmodel-file-name (string-join (list name dname "data.png") "-")])
        (draw-trees (pair dmodel-file-name dmodel-data))))

    (draw-trees (pair training-fname training-data))
    (draw-trees (pair generalization-fname generalize-data))

    (process-derived-model exemplar "exemplar")
    (process-derived-model program-exemplar "prog-exemplar")
    (process-derived-model program-compression "compress-prog")
    ))

;;(process-model prototype "proto")
         
;;(process-model parameterized-parts "param")

;;(process-model single-recursion "srecur")

;;(process-model multiple-recursion "mrecur")

(beam-compression '((g (g (g a))) (g (g (g a)))) 2)